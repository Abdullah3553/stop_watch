#define F_CPU 1000000UL


#include<avr/io.h>
#include<avr/interrupt.h>
#include<util/delay.h>
#include"types.h"
#include"clock.h"
#define RESET PD2
#define RESUME PB2
#define PAUSE PD3

time g_clock; /*Global clock*/

uint8 TIMER1_t = 0;

uint8 init_time(void)
{
	g_clock.hours = 0;
	g_clock.minutes = 0;
	g_clock.seconds = 0;
	return SUCCESS; /*Could be ignored*/
}

sint8 get_digit(uint8 number,uint8 digit )
{

	if(digit == RIGHT_DIGIT)
	{
        number = number % 10; 	/*Select the Least significant digit only*/
		return (sint8)number;
	}
	else if(digit == LEFT_DIGIT)
	{
		number = number % 100; 	/*To Select the last 2 digits only */
		number = number / 10;	/*To remove the ones digit*/
		return (sint8)number;
	}

	return DIGIT_ERROR;	/*digit was not RIGHT_DIGIT or LEFT_DIGIT*/
}

uint8 display_clock(void)
{
	/*Display the digits on the 6 7-segments */

	/*enable the tens digit in the hours*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00000001 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 )
			| ( 0x0f & ( (uint8) get_digit(g_clock.hours, LEFT_DIGIT) ) );
	_delay_ms(1);

	/*enable the ones digit in the hours*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00000010 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 )
			| ( 0x0f & ( (uint8) get_digit(g_clock.hours, RIGHT_DIGIT) ) );
	_delay_ms(1);

	/*enable the tens digit in the minutes*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00000100 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 ) |
			( 0x0f & ( (uint8) get_digit(g_clock.minutes, LEFT_DIGIT) ) );
	_delay_ms(1);

	/*enable the ones digit in the minutes*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00001000 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 )
			| ( 0x0f & ( (uint8) get_digit(g_clock.minutes, RIGHT_DIGIT) ) );
	_delay_ms(1);

	/*enable the tens digit in the seconds*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00010000 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 )
			| ( 0x0f & ( (uint8) get_digit(g_clock.seconds, LEFT_DIGIT) ) );
	_delay_ms(1);

	/*enable the ones digit in the seconds*/
	PORTA = ( PORTA & 0xc0 ) | ( 0b00100000 );
	/*Display the tens digit on the enabled 7-segment*/
	PORTC = ( PORTC & 0xf0 )
			| ( 0x0f & ( (uint8) get_digit(g_clock.seconds, RIGHT_DIGIT) ) );
	_delay_ms(1);

	return SUCCESS;
}

uint8 advance_hour(void)
{
	/*this function will increment 1 on the clock hours and handle the clock logic*/
	if(g_clock.hours == 99)
	{
		g_clock.hours = 0;
	}
	else
	{
		g_clock.hours++;
	}
	return SUCCESS;
}


uint8 advance_minute(void)
{
	/*this function will increment 1 on the clock minutes and handle the clock logic*/
	if(g_clock.minutes == 59)
	{
		g_clock.minutes = 0;
		advance_hour();
	}
	else
	{
		g_clock.minutes++;
	}
	return SUCCESS;
}

uint8 advance_second(void)
{
	/*this function will increment 1 on the clock and handle the clock logic*/
	if(g_clock.seconds == 59)
	{
		g_clock.seconds = 0;
		advance_minute();
	}
	else
	{
		g_clock.seconds++;
	}
	return SUCCESS;
}
void INT0_config(void)
{
	DDRD &= ~(1 << RESET);	/*RESET button pin*/
	PORTD |= (1 << RESET);	/*internal pull-up resistor for RESET button*/

	MCUCR &= ~(1 << ISC00);	/*INT0 on falling edge */
	MCUCR |= (1 << 	ISC01); /*INT0 on falling edge */
	GICR |= (1 << INT0); 	/*Enable INT0*/

	SREG |= (1 << SREG_I );/*Enable i-bit for global interrupt enable */

}

void INT1_config(void)
{
	DDRD &= ~(1 << PAUSE);	/*PAUSE button pin*/
							/*External pull-down resistor for PAUSE button*/

	MCUCR |= (1 << 	ISC10) 	/*INT1 on raising edge */
			| (1 << ISC11); /*INT1 on raising edge */
	GICR |= (1 << INT1); 	/*Enable INT1*/

	SREG |= (1 << SREG_I );/*Enable i-bit for global interrupt enable */

}

void INT2_config(void)
{
	DDRB &= ~(1 << RESUME) ;/*resume button*/
	PORTB |= (1 << RESUME); /*internal pull-up resistor for RESUME button*/

	MCUCSR &= ~(1 <<ISC2); 	/*INT2 on falling edge */
	GICR |= (1 << INT2); 	/*Enable INT2*/

	SREG |= (1 << SREG_I );/*Enable i-bit for global interrupt enable */

}

void TIMER1_ctc_config(void)
{
	TCNT1 = 0; /*intial value */
	OCR1A = 977; /*compare value for 1 second */
	TIMSK |= (1 << OCIE1A); /*interrupt enable bit for compare with OCR1A */
	SREG |= (1 << SREG_I );/*Enable i-bit for global interrupt enable */

	/*
	 * 1Mhz F_CPU
	 * prescaler -> 1024
	 * WGM10 and WGM11 = 0 -> ctc mode
	 * FOC1A =1, FOC1B= 0 -> force ctc mode with OCR1A
	 *
	 * */
	TCCR1A = (1 << FOC1A);
	/*
	 * CS11 = 1 -> prescaler = 1024
	 * CS10 = 1 -> prescaler = 1024
	 * WGM12 = 1 -> ctc mode
	 * WGM13 = 0 -> ctc mode
	 * */
	TCCR1B = ( 1 << CS12 ) | (1 << CS10) | ( 1 << WGM12);
	/*
	 * with this setup, each increment will be 1.024 ms.
	 *  so to get 1 second, you need to count to 977
	 * */
}

void TIMER1_resume(void)
{
	TIMSK |= (1 << OCIE1A); /*TIMER1 Interrupt enable bit*/

	SREG |= (1 << SREG_I );/*Enable i-bit for global interrupt enable */

	/*This set the clock to the timer so the timer will start*/
	TCCR1B = ( 1 << CS12 ) | (1 << CS10) | ( 1 << WGM12);
}

void TIMER1_pause(void)
{
	TIMSK &= ~(1 << OCIE1A); /*TIMER1 Interrupt enable bit*/
	TCCR1B = 0; /*No clock input*/
}

void TIMER1_reset(void)
{
	/*We can do more stuff here like changing the compare value for the timer*/
	TCNT1 = 0; /*reset value */
}


ISR(TIMER1_COMPA_vect)
{
	TIMER1_t++;
	if(TIMER1_t == 1)
	{
		/*A second passed*/
		TIMER1_t = 0;
		advance_second();
	}
}

ISR(INT0_vect)
{
	/*Should reset the clock*/
	init_time(); /*Reset the 7-segments*/

	TIMER1_reset();
}

ISR(INT1_vect)
{
	TIMER1_pause();
}

ISR(INT2_vect)
{
	TIMER1_resume();
}

int main(void)
{
	init_time(); 	/*Set the clock to zero */

	DDRA |= 0x3f; 	/*Enable Pins for all 6 7-segments */
	PORTA &= 0xc0;	/*All enable Pins are OFF*/

	DDRC |= 0x0f; 	/*4 pins for 7-segment decoder digit */
	PORTC &= 0xf0; 	/*Set the decoder digit to 0*/

	INT0_config();
	INT1_config();
	INT2_config();

	TIMER1_ctc_config(); /*Compare mode with TIMER1 that counts seconds*/

	while(1)
	{
		display_clock();
	}/*While(1) end*/


}
